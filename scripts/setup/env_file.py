#!/usr/bin/env python3
"""
Environment file management for AS-Plugins Setup Wizard.

Handles reading, updating, and backing up ~/.env files
with proper permissions (600).
"""

import os
import re
import shutil
from datetime import datetime
from pathlib import Path
from typing import Optional


def load_env_file(path: Path) -> dict:
    """
    Load environment variables from a file.

    Args:
        path: Path to the .env file

    Returns:
        Dictionary of variable name -> value
    """
    env_vars = {}

    if not path.exists():
        return env_vars

    try:
        content = path.read_text()

        for line in content.splitlines():
            line = line.strip()

            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue

            # Parse KEY=value or KEY="value" or KEY='value'
            match = re.match(r'^([A-Za-z_][A-Za-z0-9_]*)=(.*)$', line)
            if match:
                key = match.group(1)
                value = match.group(2)

                # Remove surrounding quotes
                if (value.startswith('"') and value.endswith('"')) or \
                   (value.startswith("'") and value.endswith("'")):
                    value = value[1:-1]

                env_vars[key] = value

    except Exception:
        pass

    return env_vars


def save_env_file(path: Path, env_vars: dict) -> Optional[Path]:
    """
    Save environment variables to a file.

    Creates a backup of the existing file if it exists.
    Sets file permissions to 600 (owner read/write only).

    Args:
        path: Path to the .env file
        env_vars: Dictionary of variable name -> value

    Returns:
        Path to backup file if created, None otherwise
    """
    backup_path = None

    # Create backup if file exists
    if path.exists():
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        backup_path = path.with_suffix(f".backup.{timestamp}")
        shutil.copy2(path, backup_path)

    # Group variables by prefix for organization
    prefixes = ["CONFLUENCE", "JIRA", "SPLUNK", "GITLAB"]
    grouped = {prefix: {} for prefix in prefixes}
    other = {}

    for key, value in sorted(env_vars.items()):
        found = False
        for prefix in prefixes:
            if key.startswith(prefix + "_"):
                grouped[prefix][key] = value
                found = True
                break
        if not found:
            other[key] = value

    # Build file content
    lines = []
    lines.append("# AS-Plugins Configuration")
    lines.append("# Generated by setup wizard")
    lines.append("")

    # Write grouped variables
    for prefix in prefixes:
        vars_dict = grouped[prefix]
        if vars_dict:
            lines.append(f"# {prefix.capitalize()}")
            for key, value in sorted(vars_dict.items()):
                # Quote values with spaces or special characters
                if needs_quoting(value):
                    lines.append(f'{key}="{value}"')
                else:
                    lines.append(f"{key}={value}")
            lines.append("")

    # Write other variables
    if other:
        lines.append("# Other")
        for key, value in sorted(other.items()):
            if needs_quoting(value):
                lines.append(f'{key}="{value}"')
            else:
                lines.append(f"{key}={value}")
        lines.append("")

    # Write file
    content = "\n".join(lines)
    path.write_text(content)

    # Set permissions to 600 (owner read/write only)
    os.chmod(path, 0o600)

    return backup_path


def needs_quoting(value: str) -> bool:
    """Check if a value needs to be quoted in .env file."""
    if not value:
        return True

    # Quote if contains spaces, special characters, or quotes
    special_chars = set(' \t\n\r"\'\\$`!#&|;<>(){}[]')
    return any(c in special_chars for c in value)


def mask_value(value: str, visible_chars: int = 4) -> str:
    """
    Mask a sensitive value for display.

    Args:
        value: The value to mask
        visible_chars: Number of characters to show at the end

    Returns:
        Masked value like "****abcd"
    """
    if not value:
        return "(not set)"

    if len(value) <= visible_chars:
        return "*" * len(value)

    masked_length = len(value) - visible_chars
    return "*" * min(masked_length, 8) + value[-visible_chars:]


def get_env_var(name: str, default: str = "") -> str:
    """Get environment variable from current environment or ~/.env."""
    # Check current environment first
    value = os.environ.get(name)
    if value:
        return value

    # Check ~/.env
    env_file = Path.home() / ".env"
    env_vars = load_env_file(env_file)
    return env_vars.get(name, default)


def resolve_env_var(name: str, sources: list[tuple[str, dict]]) -> tuple[str, str]:
    """
    Check multiple sources in priority order for an environment variable.

    Args:
        name: Variable name to look up
        sources: Ordered list of (label, env_dict) tuples

    Returns:
        (value, source_label) if found, ("", "") otherwise
    """
    for label, env_dict in sources:
        value = env_dict.get(name, "")
        if value:
            return value, label
    return "", ""


def discover_env_files() -> list[tuple[str, Path]]:
    """
    Discover env files that exist on disk.

    Checks:
        1. ~/.env (home directory)
        2. {as-plugins parent}/as-demo/secrets/.env (sibling project)

    Returns:
        List of (label, path) for env files that exist
    """
    results = []

    # ~/.env
    home_env = Path.home() / ".env"
    if home_env.exists():
        results.append(("~/.env", home_env))

    # as-demo/secrets/.env â€” find relative to this script's repo root
    repo_dir = Path(__file__).parent.parent.parent  # scripts/setup/env_file.py -> repo root
    as_demo_env = repo_dir.parent / "as-demo" / "secrets" / ".env"
    if as_demo_env.exists():
        results.append(("as-demo/secrets/.env", as_demo_env))

    return results
