#!/usr/bin/env python3
"""
Environment file management for AS-Plugins Setup Wizard.

Handles reading, updating, and backing up ~/.env files
with proper permissions (600).
"""

import os
import re
import shutil
from datetime import datetime
from pathlib import Path
from typing import Optional


def load_env_file(path: Path) -> dict:
    """
    Load environment variables from a file.

    Args:
        path: Path to the .env file

    Returns:
        Dictionary of variable name -> value
    """
    env_vars = {}

    if not path.exists():
        return env_vars

    try:
        content = path.read_text()

        for line in content.splitlines():
            line = line.strip()

            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue

            # Parse KEY=value or KEY="value" or KEY='value'
            match = re.match(r'^([A-Za-z_][A-Za-z0-9_]*)=(.*)$', line)
            if match:
                key = match.group(1)
                value = match.group(2)

                # Remove surrounding quotes
                if (value.startswith('"') and value.endswith('"')) or \
                   (value.startswith("'") and value.endswith("'")):
                    value = value[1:-1]

                env_vars[key] = value

    except Exception:
        pass

    return env_vars


def save_env_file(path: Path, env_vars: dict) -> Optional[Path]:
    """
    Save environment variables to a file.

    Creates a backup of the existing file if it exists.
    Sets file permissions to 600 (owner read/write only).

    Args:
        path: Path to the .env file
        env_vars: Dictionary of variable name -> value

    Returns:
        Path to backup file if created, None otherwise
    """
    backup_path = None

    # Create backup if file exists
    if path.exists():
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        backup_path = path.with_suffix(f".backup.{timestamp}")
        shutil.copy2(path, backup_path)

    # Group variables by prefix for organization
    prefixes = ["CONFLUENCE", "JIRA", "SPLUNK"]
    grouped = {prefix: {} for prefix in prefixes}
    other = {}

    for key, value in sorted(env_vars.items()):
        found = False
        for prefix in prefixes:
            if key.startswith(prefix + "_"):
                grouped[prefix][key] = value
                found = True
                break
        if not found:
            other[key] = value

    # Build file content
    lines = []
    lines.append("# AS-Plugins Configuration")
    lines.append("# Generated by setup wizard")
    lines.append("")

    # Write grouped variables
    for prefix in prefixes:
        vars_dict = grouped[prefix]
        if vars_dict:
            lines.append(f"# {prefix.capitalize()}")
            for key, value in sorted(vars_dict.items()):
                # Quote values with spaces or special characters
                if needs_quoting(value):
                    lines.append(f'{key}="{value}"')
                else:
                    lines.append(f"{key}={value}")
            lines.append("")

    # Write other variables
    if other:
        lines.append("# Other")
        for key, value in sorted(other.items()):
            if needs_quoting(value):
                lines.append(f'{key}="{value}"')
            else:
                lines.append(f"{key}={value}")
        lines.append("")

    # Write file
    content = "\n".join(lines)
    path.write_text(content)

    # Set permissions to 600 (owner read/write only)
    os.chmod(path, 0o600)

    return backup_path


def needs_quoting(value: str) -> bool:
    """Check if a value needs to be quoted in .env file."""
    if not value:
        return True

    # Quote if contains spaces, special characters, or quotes
    special_chars = set(' \t\n\r"\'\\$`!#&|;<>(){}[]')
    return any(c in special_chars for c in value)


def mask_value(value: str, visible_chars: int = 4) -> str:
    """
    Mask a sensitive value for display.

    Args:
        value: The value to mask
        visible_chars: Number of characters to show at the end

    Returns:
        Masked value like "****abcd"
    """
    if not value:
        return "(not set)"

    if len(value) <= visible_chars:
        return "*" * len(value)

    masked_length = len(value) - visible_chars
    return "*" * min(masked_length, 8) + value[-visible_chars:]


def get_env_var(name: str, default: str = "") -> str:
    """Get environment variable from current environment or ~/.env."""
    # Check current environment first
    value = os.environ.get(name)
    if value:
        return value

    # Check ~/.env
    env_file = Path.home() / ".env"
    env_vars = load_env_file(env_file)
    return env_vars.get(name, default)
